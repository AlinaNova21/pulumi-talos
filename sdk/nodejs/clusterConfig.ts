// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs, enums } from "./types";
import * as utilities from "./utilities";

/**
 * Talos cluster config resource
 */
export class ClusterConfig extends pulumi.CustomResource {
    /**
     * Get an existing ClusterConfig resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, opts?: pulumi.CustomResourceOptions): ClusterConfig {
        return new ClusterConfig(name, undefined as any, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'talos:index:clusterConfig';

    /**
     * Returns true if the given object is an instance of ClusterConfig.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ClusterConfig {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ClusterConfig.__pulumiType;
    }

    /**
     * additional Subject-Alt-Names for the APIServer certificate
     */
    public readonly additionalSans!: pulumi.Output<string[]>;
    /**
     * cluster discovery feature
     */
    public readonly clusterDiscovery!: pulumi.Output<boolean>;
    /**
     * The cluster endpoint
     */
    public readonly clusterEndpoint!: pulumi.Output<string>;
    /**
     * cluster name
     */
    public readonly clusterName!: pulumi.Output<string>;
    /**
     * generated machineconfigs (applied to all node types)
     */
    public readonly configPatches!: pulumi.Output<outputs.ConfigPatches>;
    /**
     * generated machineconfigs (applied to 'controlplane' types)
     */
    public readonly configPatchesControlPlane!: pulumi.Output<outputs.ConfigPatches>;
    /**
     * generated machineconfigs (applied to 'worker' type)
     */
    public readonly configPatchesWorker!: pulumi.Output<outputs.ConfigPatches>;
    /**
     * the desired machine config version to refer to
     */
    public readonly configVersion!: pulumi.Output<string>;
    /**
     * Talos Controlplane Config
     */
    public /*out*/ readonly controlplaneConfig!: pulumi.Output<string>;
    /**
     * the dns domain to use for cluster
     */
    public readonly dnsDomain!: pulumi.Output<string>;
    /**
     * machine config documentation enabled
     */
    public readonly docs!: pulumi.Output<boolean>;
    /**
     * machine config examples enabled
     */
    public readonly examples!: pulumi.Output<boolean>;
    /**
     * the disk to install to 
     */
    public readonly installDisk!: pulumi.Output<string>;
    /**
     * the image used to perform an installation
     */
    public readonly installImage!: pulumi.Output<string>;
    /**
     * desired kubernetes version to run
     */
    public readonly kubernetesVersion!: pulumi.Output<string>;
    /**
     * kubespan enabled
     */
    public readonly kubespan!: pulumi.Output<boolean>;
    /**
     * persist value for configs
     */
    public readonly persist!: pulumi.Output<boolean>;
    /**
     * list of registry mirrors
     */
    public readonly registryMirrors!: pulumi.Output<string[]>;
    /**
     * Talos Secrets Bundle
     */
    public readonly secrets!: pulumi.Output<outputs.SecretsBundle>;
    /**
     * the desired Talos version
     */
    public readonly talosVersion!: pulumi.Output<string>;
    /**
     * Talos Worker Config
     */
    public /*out*/ readonly workerConfig!: pulumi.Output<string>;

    /**
     * Create a ClusterConfig resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ClusterConfigArgs, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (!opts.id) {
            if ((!args || args.clusterEndpoint === undefined) && !opts.urn) {
                throw new Error("Missing required property 'clusterEndpoint'");
            }
            if ((!args || args.clusterName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'clusterName'");
            }
            if ((!args || args.secrets === undefined) && !opts.urn) {
                throw new Error("Missing required property 'secrets'");
            }
            resourceInputs["additionalSans"] = args ? args.additionalSans : undefined;
            resourceInputs["clusterDiscovery"] = (args ? args.clusterDiscovery : undefined) ?? true;
            resourceInputs["clusterEndpoint"] = args ? args.clusterEndpoint : undefined;
            resourceInputs["clusterName"] = args ? args.clusterName : undefined;
            resourceInputs["configPatches"] = args ? args.configPatches : undefined;
            resourceInputs["configPatchesControlPlane"] = args ? args.configPatchesControlPlane : undefined;
            resourceInputs["configPatchesWorker"] = args ? args.configPatchesWorker : undefined;
            resourceInputs["configVersion"] = args ? args.configVersion : undefined;
            resourceInputs["dnsDomain"] = (args ? args.dnsDomain : undefined) ?? "cluster.local";
            resourceInputs["docs"] = (args ? args.docs : undefined) ?? true;
            resourceInputs["examples"] = (args ? args.examples : undefined) ?? true;
            resourceInputs["installDisk"] = (args ? args.installDisk : undefined) ?? "/dev/sda";
            resourceInputs["installImage"] = (args ? args.installImage : undefined) ?? "ghcr.io/talos-systems/installer:v0.14.2";
            resourceInputs["kubernetesVersion"] = (args ? args.kubernetesVersion : undefined) ?? "1.23.6";
            resourceInputs["kubespan"] = args ? args.kubespan : undefined;
            resourceInputs["persist"] = (args ? args.persist : undefined) ?? true;
            resourceInputs["registryMirrors"] = args ? args.registryMirrors : undefined;
            resourceInputs["secrets"] = args ? args.secrets : undefined;
            resourceInputs["talosVersion"] = args ? args.talosVersion : undefined;
            resourceInputs["controlplaneConfig"] = undefined /*out*/;
            resourceInputs["workerConfig"] = undefined /*out*/;
        } else {
            resourceInputs["additionalSans"] = undefined /*out*/;
            resourceInputs["clusterDiscovery"] = undefined /*out*/;
            resourceInputs["clusterEndpoint"] = undefined /*out*/;
            resourceInputs["clusterName"] = undefined /*out*/;
            resourceInputs["configPatches"] = undefined /*out*/;
            resourceInputs["configPatchesControlPlane"] = undefined /*out*/;
            resourceInputs["configPatchesWorker"] = undefined /*out*/;
            resourceInputs["configVersion"] = undefined /*out*/;
            resourceInputs["controlplaneConfig"] = undefined /*out*/;
            resourceInputs["dnsDomain"] = undefined /*out*/;
            resourceInputs["docs"] = undefined /*out*/;
            resourceInputs["examples"] = undefined /*out*/;
            resourceInputs["installDisk"] = undefined /*out*/;
            resourceInputs["installImage"] = undefined /*out*/;
            resourceInputs["kubernetesVersion"] = undefined /*out*/;
            resourceInputs["kubespan"] = undefined /*out*/;
            resourceInputs["persist"] = undefined /*out*/;
            resourceInputs["registryMirrors"] = undefined /*out*/;
            resourceInputs["secrets"] = undefined /*out*/;
            resourceInputs["talosVersion"] = undefined /*out*/;
            resourceInputs["workerConfig"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["controlplaneConfig", "secrets", "workerConfig"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(ClusterConfig.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * The set of arguments for constructing a ClusterConfig resource.
 */
export interface ClusterConfigArgs {
    /**
     * additional Subject-Alt-Names for the APIServer certificate
     */
    additionalSans?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * enable cluster discovery feature (default true)
     */
    clusterDiscovery?: pulumi.Input<boolean>;
    /**
     * The cluster endpoint is the URL for the Kubernetes API. If you decide to use
     * a control plane node, common in a single node control plane setup, use port 6443 as
     * this is the port that the API server binds to on every control plane node. For an HA
     * setup, usually involving a load balancer, use the IP and port of the load balancer.
     */
    clusterEndpoint: pulumi.Input<string>;
    /**
     * cluster name
     */
    clusterName: pulumi.Input<string>;
    /**
     * patch generated machineconfigs (applied to all node types)
     */
    configPatches?: pulumi.Input<inputs.ConfigPatchesArgs>;
    /**
     * patch generated machineconfigs (applied to 'controlplane' types)
     */
    configPatchesControlPlane?: pulumi.Input<inputs.ConfigPatchesArgs>;
    /**
     * patch generated machineconfigs (applied to 'worker' type)
     */
    configPatchesWorker?: pulumi.Input<inputs.ConfigPatchesArgs>;
    /**
     * the desired machine config version to refer to
     */
    configVersion?: pulumi.Input<string>;
    /**
     * the dns domain to use for cluster (default "cluster.local")
     */
    dnsDomain?: pulumi.Input<string>;
    /**
     * renders all machine configs adding the documentation for each field (default true)
     */
    docs?: pulumi.Input<boolean>;
    /**
     * renders all machine configs with the commented examples (default true)
     */
    examples?: pulumi.Input<boolean>;
    /**
     * the disk to install to (default "/dev/sda")
     */
    installDisk?: pulumi.Input<string>;
    /**
     * the image used to perform an installation (default "ghcr.io/talos-systems/installer:v0.14.2")
     */
    installImage?: pulumi.Input<string>;
    /**
     * desired kubernetes version to run (default "1.23.6")
     */
    kubernetesVersion?: pulumi.Input<string>;
    /**
     * enable kubespan feature
     */
    kubespan?: pulumi.Input<boolean>;
    /**
     * the desired persist value for configs (default true)
     */
    persist?: pulumi.Input<boolean>;
    /**
     * list of registry mirrors to use in format: <registry host>=<mirror URL>
     */
    registryMirrors?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Talos Secrets Bundle
     */
    secrets: pulumi.Input<inputs.SecretsBundleArgs>;
    /**
     * the desired Talos version to refer to
     */
    talosVersion?: pulumi.Input<string>;
}
